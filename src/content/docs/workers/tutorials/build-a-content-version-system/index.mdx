---
updated: 2024-11-10
difficulty: Beginner
content_type: üìùTutorial
pcx_content_type: tutorial
title: Build a version control system with Cloudflare Workers and Durable Objects
products:
  - Workers
  - Durable Objects
languages:
  - TypeScript
---

import { Render, PackageManagers } from "~/components";

Version Control Systems allow you record several versions of a project or file, which can be backtracked to at any point in time. Git is an example of a version control system.

In this tutorial, you will build a version control system powered by Cloudflare that can track changes made to content such as files of text or code. Cloudflare Workers will be used to handle functions such as creating versions for content, and Durable Objects will be used to record version states.

The functions which we will be covering in this tutorial are as follows:
- Create a new content
- Update the content
- Get the content (specific version and list of all versions)
- Revert to a specific version
- Publish or unpublish a version
- Detailed history of modifications
- Tag a version
- Delete a version (in case you do not need it anymore)

## Prerequisites

<Render file="prereqs" product="workers" />

A Cloudflare account with a [Workers Paid plan](/workers/platform/pricing/#workers) is required so that you can use Durable Objects.

## 1. Set up Worker project and Durable Objects

To create a Worker project that is ready to use Durable Objects, run [C3 (create-cloudflare-cli)](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare) in your CLI.

```sh
mkdir content-version-system
cd content-version-system

npm create cloudflare@latest
```

After running the command above, you will be asked to provide information on what kind of project you would like to create. Use the following values:

```sh
Ok to proceed? (y) y
In which directory do you want to create your application?
‚îÇ ./content-version-system
‚îú What would you like to start with?
‚îÇ Hello World example
‚îÇ
‚îú Which template would you like to use?
‚îÇ Hello World Worker Using Durable Objects
‚îÇ
‚îú Which language do you want to use?
‚îÇ TypeScript
‚îú Do you want to use git for version control?
‚îÇ yes
‚îú Do you want to deploy your application?
‚îÇ no
```

### Configure the Worker and Durable Object binding

Once `C3` has finished running, you should now have a Workers project with the name `content-version-system` that contains Cloudflare's development tool [Wrangler](/workers/wrangler/) along following files and directories:

```sh
~/content-version-system/content-version-system# ls

node_modules  package.json  package-lock.json  src  tsconfig.json  worker-configuration.d.ts  wrangler.toml
```
Modify the `wrangler.toml` configuration file by adding a Durable Objects binding that enables the Worker application to communicate with the Durable Object.

```toml title="wrangler.toml"
name = "content-version-system"
main = "src/index.ts"
compatibility_date = "2024-11-06"

[observability]
enabled = true

[placement]
mode = "smart"

[[durable_objects.bindings]]
name = "CONTENT"
class_name = "ContentDO"

[[migrations]]
tag = "v1"
new_classes = ["ContentDO"]
```

### Install required packages

List of packages that will be used in this project:

- `diff` - A text diffing implementation for JavaScript
- `itty-router` - A tiny, zero-dependency router designed for Cloudflare Workers
- `@cloudflare/workers-types` - TypeScript type definitions for Cloudflare Workers
- `@types/diff` - TypeScript type definitions for the diff package
- `@typescript-eslint/eslint-plugin` - ESLint plugin for TypeScript
- `@typescript-eslint/parser` - Parser for TypeScript files in ESLint
- `eslint` - JavaScript/TypeScript linter
- `prettier` - Code formatter
- `typescript` - TypeScript compiler and language tools
- `vitest` - Unit testing framework
- `wrangler` - Cloudflare Workers CLI and development tool

Replace the `package.json` with following content:

```json
{
  "name": "content-version-system",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "deploy": "wrangler deploy",
    "dev": "wrangler dev",
    "start": "wrangler dev",
    "cf-typegen": "wrangler types",
    "lint": "npx eslint . --ext .ts --fix",
    "format": "prettier --write .",
    "test": "vitest run",
    "test:watch": "vitest"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20241106.0",
    "@types/diff": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "eslint": "^8.56.0",
    "prettier": "^3.2.5",
    "typescript": "^5.3.3",
    "vitest": "^1.2.2",
    "wrangler": "^3.60.3"
  },
  "dependencies": {
    "diff": "^7.0.0",
    "itty-router": "^5.0.18"
  }
}
```
Then run `npm install` to install the dependencies.

### Configure tsconfig.json file

The tsconfig.json file needs to be updated to ensure proper TypeScript compilation and compatibility with the project dependencies, particularly for Cloudflare Workers types and module resolution.

Edit the content of the `tsconfig.json` file:

```json
{
    "compilerOptions": {
        "target": "ES2022",
        "lib": ["ES2022"],
        "jsx": "react-jsx",
        "module": "ES2022",
        "moduleResolution": "node",
        "types": ["@cloudflare/workers-types"],
        "baseUrl": ".",
        "paths": {
            "@/*": ["./src/*"]
        },
        "resolveJsonModule": true,
        "allowJs": true,
        "checkJs": false,
        "noEmit": true,
        "isolatedModules": true,
        "allowSyntheticDefaultImports": true,
        "forceConsistentCasingInFileNames": true,
        "strict": true,
        "skipLibCheck": true
    },
    "include": ["src/**/*", "worker-configuration.d.ts"]
}
```

## 2. Define the data structures for a version control system

Create the files 'types.ts' and 'contentDO.ts' inside the 'src' directory. The file structure will be as follows:

```sh
.src
    ‚îî‚îÄ‚îÄ‚îÄtypes.ts     <--- Interface definitions for data structures
    ‚îî‚îÄ‚îÄ‚îÄindex.ts     <--- Entry point for request routing and presentation
    ‚îî‚îÄ‚îÄ‚îÄcontentDO.ts <--- Core business logic
```

The data structures that will be used by the Durable Object and the Worker to handle state management must first be defined. In this step the following data will be defined:

- The different states a content version can have (`draft`, `published` and `archived`).
- The core data structure for version management, such as a version id number, the contained content and the attached version message.
- The data structure to track version events and history.
- The API response structure.

Add the following code to the `src/types.ts` file:

```typescript
// Core version statuses - Define possible states of a content version
export enum VersionStatus {
  DRAFT = 'draft',
  PUBLISHED = 'published',
  ARCHIVED = 'archived'
}

// Version & tag structures - Define core data structures for version management
export interface Version {
  id: number;
  content: string;
  timestamp: string;
  message: string;
  diff?: ContentDiff;
  status: VersionStatus;
}

export interface Tag {
  name: string;
  versionId: number;
  createdAt: string;
  updatedAt?: string;
}

// State management - Define how content versions and states are tracked
export interface ContentState {
  currentVersion: number;
  versions: Version[];
  tags: { [key: string]: Tag };
  content: string | null;
  publishHistory: PublishRecord[];
}

// Change tracking - tracking differences between versions
export interface ContentDiff {
  from: string;
  to: string;
  changes: {
    additions: number;
    deletions: number;
    totalChanges: number;
    timestamp: string;
  };
  patch: string;
  hunks: Array<{
    oldStart: number;
    oldLines: number;
    newStart: number;
    newLines: number;
    lines: string[];
  }>;
}

// Publishing system - Track publishing events and history
export interface PublishRecord {
  versionId: number;
  publishedAt: string;
  publishedBy: string;
}

// API response types - Standardized response structures for the API
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export interface DeleteVersionResponse {
  success: boolean;
  message: string;
}

export interface TagResponse {
  tagName: string;
  versionId: number;
}

export interface CurrentVersionResponse {
  version: number;
  content: string | null;
}

export type VersionListItem = Omit<Version, 'content' | 'diff'>;
```

## 3. Handle requests sent to the Durable Object

Cloudflare Workers will route incoming requests to the Durable Objects instance. The Durable Objects instance then processes the request, and provides the appropriate response to the Worker.

To handle incoming requests, add the following code to `src/index.ts`:

### Initial setup and HTML template

```typescript
import { ContentDO } from './contentDO';

interface Env {
  CONTENT: DurableObjectNamespace;
}

// HTML Template & Styling. This is used to display the published content when the user navigates to the root URL.
// For full HTML template and styling details, see the GitHub repository.
const getHtmlTemplate = (content: string, message: string = '', timestamp: string = '') => `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Content Version System</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .content {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            white-space: pre-wrap;
        }
        .button {
            background: #0070f3;
            color: white;
            padding: 12px 24px;
            border-radius: 5px;
            text-decoration: none;
            display: inline-block;
            margin-top: 20px;
        }
        .button:hover {
            background: #0051a2;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .meta {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Content Version System</h1>
    <div class="content">
        <div class="meta">
            <strong>Message:</strong> ${message}<br>
            <strong>Last Updated:</strong> ${new Date(timestamp).toLocaleString()}
        </div>
        <h2>Current Content:</h2>
        <pre>${content}</pre>
    </div>
    <a href="http://localhost:3000" class="button">Content Version Management</a>
</body>
</html>
`;
// TODO: CORS and helper functions
```
### CORS and helper functions

Set up CORS headers to allow cross-origin requests, then add a function to retrieve the latest published version of content from durable objects. Add the following code to `src/index.ts`:

```typescript
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, HEAD, POST, PUT, OPTIONS, DELETE',
  'Access-Control-Allow-Headers': 'Content-Type',
};

// Helper function to get latest published version from Durable Objects
async function getLatestPublishedVersion(contentDO: DurableObjectInstance, origin: string) {
  const versionsResponse = await contentDO.fetch(new Request(origin + '/content/default/versions'));
  const versions = await versionsResponse.json();

  const publishedVersions = versions.filter((v: any) => v.status === 'published');
  if (publishedVersions.length === 0) {
    return null;
  }

  return publishedVersions.reduce((latest: any, current: any) => 
    latest.id > current.id ? latest : current
  );
}

// TODO: Request handler
```

### Request handler

Add the following code to `src/index.ts` to handle requests for the Durable Object:

```typescript
export { ContentDO };

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    try {
      const url = new URL(request.url);
      // Handle CORS preflight
      if (request.method === 'OPTIONS') {
        return new Response(null, { headers: corsHeaders });
      }
      // Get Durable Objects instance
      const doId = env.CONTENT.idFromName('default');
      const contentDO = env.CONTENT.get(doId);
      // Handle root path - show HTML view
      if (url.pathname === '/') {
        try {
          const latestPublished = await getLatestPublishedVersion(contentDO, url.origin);
          // If there is published content, fetch it and display it
          if (latestPublished) {
            const contentResponse = await contentDO.fetch(
              new Request(`${url.origin}/content/default/versions/${latestPublished.id}`)
            );
            const contentData = await contentResponse.json();
            
            return new Response(
              getHtmlTemplate(
                contentData.content || 'No content available',
                contentData.message,
                contentData.timestamp
              ), {
                headers: { 'Content-Type': 'text/html' }
              }
            );
          } else {
            return new Response(getHtmlTemplate('No published content available', 'No published versions', ''), {
              headers: { 'Content-Type': 'text/html' }
            });
          }
        } catch (error) {
          console.error('Root error:', error);
          return new Response(getHtmlTemplate('Error loading content', 'Error occurred', ''), {
            headers: { 'Content-Type': 'text/html' }
          });
        }
      }
      // Special handling for /content/default
      if (url.pathname === '/content/default') {
        try {
          const latestPublished = await getLatestPublishedVersion(contentDO, url.origin);
          
          if (latestPublished) {
            const contentResponse = await contentDO.fetch(
              new Request(`${url.origin}/content/default/versions/${latestPublished.id}`)
            );
            const contentData = await contentResponse.json();

            return new Response(JSON.stringify(contentData), {
              headers: {
                'Content-Type': 'application/json',
                ...corsHeaders
              }
            });
          } else {
            return new Response(JSON.stringify({ error: 'No published content available' }), {
              status: 404,
              headers: {
                'Content-Type': 'application/json',
                ...corsHeaders
              }
            });
          }
        } catch (error) {
          console.error('Content default error:', error);
          return new Response(JSON.stringify({ error: error.message }), {
            status: 500,
            headers: {
              'Content-Type': 'application/json',
              ...corsHeaders
            }
          });
        }
      }

      // Forward all other requests to Durable Objects
      const response = await contentDO.fetch(request);
      // Add CORS headers
      const newResponse = new Response(response.body, response);
      Object.entries(corsHeaders).forEach(([key, value]) => {
        newResponse.headers.set(key, value);
      });
      
      return newResponse;

    } catch (error) {
      console.error('Worker error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message 
      }), { 
        status: 500,
        headers: {
          'Content-Type': 'application/json',
          ...corsHeaders 
        }
      });
    }
  }
};
```

## 4. Build the core version control system logic

To handle version control functions, add the following code to `src/contentDO.ts`:

This file allow you to perform Create - Update - Delete - Read (CRUD) operations on the content versions and the version tags. Additionally, it is possible to either publish or unpublish a version, obtain detailed information on the modification history, compare versions (similar to the git `diff command`), and go back to a particular version.
- All the states are recorded in the Durable Object storage.
- Operations occur in the following order: read the state ‚Üí process changes ‚Üí write the changes.
- All operations are asynchronous because of storage communications
- There are 2 important things you have to pay attention to: First, you need to setup the CORS headers to allow cross-origin requests. Second, the class name of the Durable Object must match the name defined in the wrangler.toml file (Otherwise, error when you run `wrangler deploy` command).

### Initial setup and class definition

```typescript
import { createPatch } from 'diff';
import { ContentDiff, ContentState, Version, PublishRecord, VersionStatus, Tag } from './types';
// You will need to set up CORS headers (cross-origin requests) for your application to work properly with Durable Objects.
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type',
};
// Note that the name of the class have to match the name of the Durable Object defined in the wrangler.toml file.
export class ContentDO {
  private state: DurableObjectState;
  private env: any;

  constructor(state: DurableObjectState, env: any) {
    this.state = state;
    this.env = env;
  }
  // TODO: Request handling and routing
}
```

**Please note that all code snippets in the following sections are implemented inside the ContentDO class.**

### Request handling and routing

Add the request handling methods to `src/contentDO.ts`:

```typescript
// Entry point for requests to the Durable Object
async fetch(request: Request): Promise<Response> {
  if (request.method === 'OPTIONS') {
    return new Response(null, {
      headers: corsHeaders
    });
  }

  try {
    const url = new URL(request.url);
    const parts = url.pathname.split('/').filter(Boolean);

    console.log('ContentDO handling request:', request.method, url.pathname);
    console.log('Parts:', parts);

    const response = await this.handleRequest(request, parts);
    
    Object.entries(corsHeaders).forEach(([key, value]) => {
      response.headers.set(key, value);
    });

    return response;
  } catch (err) {
    const error = err as Error;
    console.error('Error:', error);
    return new Response(error.message, { 
      status: 500,
      headers: corsHeaders
    });
  }
}

private async handleRequest(request: Request, parts: string[]): Promise<Response> {
  const path = parts.join('/');
  console.log('Handling path:', request.method, path);

  switch (`${request.method} ${path}`) {
    
    case 'POST content': {
      const { content, message } = await request.json();
      const version = await this.createVersion(content, message);
      return Response.json(version);
    }

    case 'GET content/default': {
      const data = await this.initialize();
      if (!data.currentVersion) {
        return Response.json(null);
      }
      const version = await this.getVersion(data.currentVersion);
      return Response.json(version);
    }

    case 'GET content/default/versions': {
      const versions = await this.getVersions();
      return Response.json(versions);
    }

    case `GET content/default/versions/${parts[3]}`: {
      const version = await this.getVersion(parseInt(parts[3]));
      return Response.json(version);
    }

    case `DELETE content/default/versions/${parts[3]}`: {
      const versionId = parseInt(parts[3]);
      const result = await this.deleteVersion(versionId);
      return Response.json(result);
    }

    case 'GET content/versions/tags': {
      const tags = await this.getTags();
      return Response.json(tags);
    }

    case `GET content/versions/${parts[2]}/tags`: {
      const versionId = parseInt(parts[2]);
      const tags = await this.getVersionTags(versionId);
      return Response.json(tags);
    }

    case 'POST content/versions/tags': {
      const { versionId, name } = await request.json();
      const tag = await this.createTag(versionId, name);
      return Response.json(tag);
    }

    case `PUT content/versions/tags/${parts[3]}`: {
      const { newName } = await request.json();
      const tag = await this.updateTag(parts[3], newName);
      return Response.json(tag);
    }

    case `DELETE content/versions/tags/${parts[3]}`: {
      const result = await this.deleteTag(parts[3]);
      return Response.json(result);
    }

    case `POST content/default/versions/${parts[3]}/publish`: {
      const { publishedBy } = await request.json();
      const result = await this.publishVersion(parseInt(parts[3]), publishedBy);
      return Response.json(result);
    }

    case `POST content/default/versions/${parts[3]}/unpublish`: {
      const result = await this.unpublishVersion(parseInt(parts[3]));
      return Response.json(result);
    }

    case 'GET content/default/publish-history': {
      const history = await this.getPublishHistory();
      return Response.json(history);
    }

    case `GET content/default/versions/${parts[3]}/diff`: {
      const compareToId = parseInt(new URL(request.url).searchParams.get('compare') || '0');
      if (compareToId) {
        return await this.getDiff(parseInt(parts[3]), compareToId);
      }
      const diff = await this.compareVersions(parseInt(parts[3]), parseInt(parts[3]) - 1);
      return Response.json(diff);
    }

    case `POST content/default/revert`: {
      const { versionId } = await request.json();
      const version = await this.revertTo(versionId);
      return Response.json(version);
    }

    default:
      return new Response('No route matched: ' + request.method + ' ' + path, { status: 404 });
  }
}

// TODO: Core Version Control Functions
```

### Core version control functions

Following are the basic version control operations:

```typescript
// Initialize or get existing state from Durable Objects storage
private async initialize(): Promise<ContentState> {
  // Get existing state from Durable Objects storage
  const stored = await this.state.storage.get<ContentState>("content");
  if (!stored) {
    // Initialize the state if not existed
    const initialData: ContentState = {
      currentVersion: 0,
      versions: [],
      tags: {},
      content: null,
      publishHistory: []
    };
    await this.state.storage.put("content", initialData);
    return initialData;
  }
  return stored;
}

// Calculate next version ID based on existing versions
private getNextVersionId(data: ContentState): number {
  return data.versions.length > 0 
    ? Math.max(...data.versions.map(v => v.id)) + 1 
    : 1;
}

// Create a new version with the provided content and message
async createVersion(content: string, message: string = ""): Promise<Version> {
  const data = await this.initialize();
    
  const newVersion: Version = {
    id: this.getNextVersionId(data),
    content,
    timestamp: new Date().toISOString(),
    message,
    status: VersionStatus.DRAFT,
    diff: data.content ? this.calculateDetailedDiff(data.content, content) : null
  };

  data.versions.push(newVersion);
  data.currentVersion = newVersion.id;
  data.content = content;

  await this.state.storage.put("content", data);
  return newVersion;
}

// Get all versions
async getVersions(): Promise<Version[]> {
  const data = await this.initialize();
  return data.versions;
}

// Get a specific version by ID
async getVersion(id: number): Promise<Version | null> {
  const data = await this.initialize();
  return data.versions.find(v => v.id === id) || null;
}

// Delete a specific version by ID
async deleteVersion(id: number): Promise<{ success: boolean }> {
  const data = await this.initialize();
    
  const versionIndex = data.versions.findIndex(v => v.id === id);
  if (versionIndex === -1) {
    throw new Error("Version not found");
  }

  const version = data.versions[versionIndex];
  if (version.status === VersionStatus.PUBLISHED) {
    throw new Error("Cannot delete published version");
  }

  data.versions.splice(versionIndex, 1);

  if (data.currentVersion === id) {
    data.currentVersion = 0;
    data.content = null;
  }

  // Remove any tags associated with this version
  for (const tagName in data.tags) {
    if (data.tags[tagName].versionId === id) {
      delete data.tags[tagName];
    }
  }

  await this.state.storage.put("content", data);
  return {
    success: true
  };
}

// TODO: Tag Management Functions
```

### Tag management functions 

```typescript
async getTags(): Promise<Tag[]> {
  const data = await this.initialize();
  return Object.entries(data.tags).map(([name, tag]) => ({
    name,
    ...tag
  }));
}

async getVersionTags(versionId: number): Promise<Tag[]> {
  const data = await this.initialize();
  return Object.entries(data.tags)
    .filter(([_, tag]) => tag.versionId === versionId)
    .map(([name, tag]) => ({
      name,
      ...tag
    }));
}

async createTag(versionId: number, name: string): Promise<Tag> {
  const data = await this.initialize();
  if (data.tags[name]) {
    throw new Error("Tag already exists");
  }

  const version = data.versions.find(v => v.id === versionId);
  if (!version) {
    throw new Error("Version not found");
  }

  const tag: Tag = {
    name,
    versionId,
    createdAt: new Date().toISOString()
  };
  data.tags[name] = tag;
  await this.state.storage.put("content", data);
  return tag;
}

async updateTag(name: string, newName: string): Promise<Tag> {
  const data = await this.initialize();
  
  if (!data.tags[name]) {
    throw new Error("Tag not found");
  }

  if (data.tags[newName]) {
    throw new Error("New tag name already exists");
  }

  const tag = data.tags[name];
  delete data.tags[name];
  data.tags[newName] = {
    ...tag,
    name: newName
  };

  await this.state.storage.put("content", data);
  return {
    ...data.tags[newName],
    name: newName
  };
}

async deleteTag(name: string): Promise<{ success: boolean; message: string }> {
  const data = await this.initialize();
  
  if (!data.tags[name]) {
    throw new Error("Tag not found");
  }

  delete data.tags[name];
  await this.state.storage.put("content", data);

  return {
    success: true,
    message: `Tag ${name} deleted successfully`
  };
}

// TODO: Publishing and unpublishing functions
```

### Publishing and unpublishing functions

```typescript
async publishVersion(versionId: number, publishedBy: string): Promise<PublishRecord> {
  const data = await this.initialize();
  const version = data.versions.find(v => v.id === versionId);
  if (!version) {
    throw new Error("Version not found");
  }

  data.versions = data.versions.map(v => ({
    ...v,
    status: v.id === versionId ? VersionStatus.PUBLISHED : VersionStatus.DRAFT
  }));

  const publishRecord: PublishRecord = {
    versionId,
    publishedAt: new Date().toISOString(),
    publishedBy
  };

  if (!data.publishHistory) {
    data.publishHistory = [];
  }
  data.publishHistory.push(publishRecord);

  data.currentVersion = versionId;
  data.content = version.content;

  await this.state.storage.put("content", data);
  return publishRecord;
}

// Unpublish a version
async unpublishVersion(versionId: number): Promise<Version> {
  const data = await this.initialize();
  const version = data.versions.find(v => v.id === versionId);
  if (!version) {
    throw new Error("Version not found");
  }
  data.versions = data.versions.map(v => ({
    ...v,
    status: v.id === versionId ? VersionStatus.DRAFT : v.status
  }));
  if (data.publishHistory) {
    data.publishHistory = data.publishHistory.filter(
      record => record.versionId !== versionId
    );
  }
  if (data.currentVersion === versionId) {
    data.currentVersion = 0;
    data.content = null;
  }
  await this.state.storage.put("content", data);
  const updatedVersion = data.versions.find(v => v.id === versionId);
  if (!updatedVersion) {
    throw new Error("Failed to get updated version");
  }
  return updatedVersion;
}

async getPublishHistory(): Promise<PublishRecord[]> {
  const data = await this.initialize();
  return data.publishHistory || [];
}

// TODO: Diff and version control operations
```

### Diff and version control operations

```typescript
async compareVersions(fromId: number, toId: number): Promise<ContentDiff> {
  const data = await this.initialize();
  const fromVersion = data.versions.find(v => v.id === fromId);
  const toVersion = data.versions.find(v => v.id === toId);
  if (!fromVersion || !toVersion) {
    throw new Error("Version not found");
  }
  return this.calculateDetailedDiff(fromVersion.content, toVersion.content);
}

private calculateDetailedDiff(oldContent: string, newContent: string): ContentDiff {
  const patch = createPatch('content', 
    oldContent,
    newContent,
    'old version',
    'new version'
  );

  const oldLines = oldContent.split('\n');
  const newLines = newContent.split('\n');

  return {
    from: oldContent,
    to: newContent,
    changes: {
      additions: newLines.length - oldLines.length,
      deletions: Math.max(0, oldLines.length - newLines.length),
      totalChanges: Math.abs(newLines.length - oldLines.length),
      timestamp: new Date().toISOString()
    },
    patch: patch,
    hunks: []
  };
}

async getDiff(fromVersionId: number, toVersionId: number): Promise<Response> {
  const data = await this.initialize();
  const fromVersion = data.versions.find(v => v.id === fromVersionId);
  const toVersion = data.versions.find(v => v.id === toVersionId);
  
  if (!fromVersion || !toVersion) {
    throw new Error("Version not found");
  }

  const formattedDiff = [
    `Comparing Version ${fromVersion.id} -> Version ${toVersion.id}`,
    `From: ${fromVersion.message}`,
    `To: ${toVersion.message}`,
    '\nContent in Version ' + fromVersion.id + ':',
    fromVersion.content,
    '\nContent in Version ' + toVersion.id + ':',
    toVersion.content,
    '\nDifferences:',
    '===================================================================',
    createPatch('content.txt',
      fromVersion.content || '',
      toVersion.content || '',
      `Version ${fromVersion.id} (${fromVersion.message})`,
      `Version ${toVersion.id} (${toVersion.message})`
    )
  ].join('\n');

  return new Response(formattedDiff, {
    headers: {
      'Content-Type': 'text/plain',
      'Access-Control-Allow-Origin': '*',
    }
  });
}

async revertTo(versionId: number): Promise<Version> {
  const data = await this.initialize();
  const targetVersion = data.versions.find(v => v.id === versionId);
  if (!targetVersion) {
    throw new Error("Version not found");
  }

  const newVersion: Version = {
    id: this.getNextVersionId(data),
    content: targetVersion.content,
    timestamp: new Date().toISOString(),
    message: `Reverted to version ${versionId}`,
    status: targetVersion.status,
    diff: this.calculateDetailedDiff(
      data.versions[data.versions.length - 1]?.content || '',
      targetVersion.content
    )
  };

  data.versions.push(newVersion);
  await this.state.storage.put("content", data);
  return newVersion;
}
```
## 5. Testing and Deployment

You can test your project locally using Wrangler:

```sh
npx wrangler dev
```

In your browser, navigate to `http://localhost:8787` to preview your project.

When you are happy with the result, deploy your project:

```sh
wrangler deploy
```

Here are some commands that you can use to test your project after deployment:

### Version Management Operations

```sh
# Create a new version
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"content": "Version 1 content", "message": "First version"}' \
  https://<your-worker-url>/content

# Get current version
curl -X GET \
  https://<your-worker-url>/content/default # If you have not yet publish any version. This command will return: "No published content available"

# List all versions
curl -X GET \
  https://<your-worker-url>/content/default/versions

# Get specific version
# Replace {id} with your actual id. Eg: if you want to see content of version 1: curl -X GET \
#  https://<your-worker-url>/content/default/versions/1
curl -X GET \
  https://<your-worker-url>/content/default/versions/{id}

# Compare versions
# Replace {id1} and {id2} with your actual id. Eg: if you want to compare the differences between version 1 and version 2: 
# curl -X GET \
#  https://content-version-system.sycu-lee.workers.dev/content/default/versions/1/diff?compare=2
curl -X GET \
  https://<your-worker-url>/content/default/versions/{id1}/diff?compare={id2}
```

### Tag operations

```sh
# Create a new tag
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"versionId": 1, "name": "v1.0"}' \
  https://<your-worker-url>/content/versions/tags

# List all tags
curl -X GET \
  https://<your-worker-url>/content/versions/tags

# Update tag name
curl -X PUT \
  -H "Content-Type: application/json" \
  -d '{"newName": "stable"}' \
  https://<your-worker-url>/content/versions/tags/v1.0
```

### Publish and unpublish operations

```sh
# Publish a version
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"publishedBy": "test-user"}' \
  https://<your-worker-url>/content/default/versions/{id}/publish

# View publication history
curl -X GET \
  https://<your-worker-url>/content/default/publish-history
```

## 6. Additional resources
If you want to implement CI/CD for Worker platform, you can navigate to this blog: [Continuous Deployment for Cloudflare Workers with GitHub Actions](https://blog.cloudflare.com/workers-builds-integrated-ci-cd-built-on-the-workers-platform/)

You can find source code for this project on: [GitHub](https://github.com/shinchan79/content-version-system.git)
