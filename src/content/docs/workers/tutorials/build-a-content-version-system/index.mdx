---
updated: 2024-11-10
difficulty: Beginner
content_type: üìùTutorial
pcx_content_type: tutorial
title: Build a version control system with Cloudflare Workers and Durable Objects
products:
  - Workers
  - Durable Objects
languages:
  - TypeScript
---

import { Render, PackageManagers } from "~/components";

Version Control Systems allow you record several versions of a project or file, which can be backtracked to at any point in time. Git is an example of a version control system.

In this tutorial, you will build a version control system powered by Cloudflare that can track changes made to content such as files of text or code. Cloudflare Workers will be used to handle functions such as creating versions for content, and Durable Objects will be used to record version states.

The functions which we will be covering in this tutorial are as follows:
- Create a new content
- Update the content
- Get the content (specific version and list of all versions)
- Revert to a specific version
- Publish or unpublish a version
- Detailed history of modifications
- Tag a version
- Delete a version (in case you do not need it anymore)

## Prerequisites

<Render file="prereqs" product="workers" />

A Cloudflare account with a [Workers Paid plan](/workers/platform/pricing/#workers) is required so that you can use Durable Objects.

## 1. Set up Worker project and Durable Objects

To create a Worker project that is ready to use Durable Objects, run [C3 (create-cloudflare-cli)](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare) in your CLI.

```sh
mkdir content-version-system
cd content-version-system

npm create cloudflare@latest
```

After running the command above, you will be asked to provide information on what kind of project you would like to create. Use the following values:

```sh
Ok to proceed? (y) y
In which directory do you want to create your application?
‚îÇ ./content-version-system
‚îú What would you like to start with?
‚îÇ Hello World example
‚îÇ
‚îú Which template would you like to use?
‚îÇ Hello World Worker Using Durable Objects
‚îÇ
‚îú Which language do you want to use?
‚îÇ TypeScript
‚îú Do you want to use git for version control?
‚îÇ yes
‚îú Do you want to deploy your application?
‚îÇ no
```

### Configure the Worker and Durable Object binding

Once `C3` has finished running, you should now have a Workers project with the name `content-version-system` that contains Cloudflare's development tool [Wrangler](/workers/wrangler/) along following files and directories:

```sh
~/content-version-system/content-version-system# ls

node_modules  package.json  package-lock.json  src  tsconfig.json  worker-configuration.d.ts  wrangler.toml
```
Modify the `wrangler.toml` configuration file by adding a Durable Objects binding that enables the Worker application to communicate with the Durable Object.

```toml title="wrangler.toml"
name = "content-version-system"
main = "src/index.ts"
compatibility_date = "2024-11-06"

[observability]
enabled = true

[placement]
mode = "smart"

[[durable_objects.bindings]]
name = "CONTENT"
class_name = "ContentDO"

[[migrations]]
tag = "v1"
new_classes = ["ContentDO"]
```

### Install required packages

List of packages that will be used in this project:

- `diff` - A text diffing implementation for JavaScript
- `itty-router` - A tiny, zero-dependency router designed for Cloudflare Workers
- `@cloudflare/workers-types` - TypeScript type definitions for Cloudflare Workers
- `@types/diff` - TypeScript type definitions for the diff package
- `@typescript-eslint/eslint-plugin` - ESLint plugin for TypeScript
- `@typescript-eslint/parser` - Parser for TypeScript files in ESLint
- `eslint` - JavaScript/TypeScript linter
- `prettier` - Code formatter
- `typescript` - TypeScript compiler and language tools
- `vitest` - Unit testing framework
- `wrangler` - Cloudflare Workers CLI and development tool

Replace the `package.json` with following content:

```json
{
  "name": "content-version-system",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "deploy": "wrangler deploy",
    "dev": "wrangler dev",
    "start": "wrangler dev",
    "cf-typegen": "wrangler types",
    "lint": "npx eslint . --ext .ts --fix",
    "format": "prettier --write .",
    "test": "vitest run",
    "test:watch": "vitest"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20241106.0",
    "@types/diff": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "eslint": "^8.56.0",
    "prettier": "^3.2.5",
    "typescript": "^5.3.3",
    "vitest": "^1.2.2",
    "wrangler": "^3.60.3"
  },
  "dependencies": {
    "diff": "^7.0.0",
    "itty-router": "^5.0.18"
  }
}
```
Then run `npm install` to install the dependencies.

### Configure tsconfig.json file

The tsconfig.json file needs to be updated to ensure proper TypeScript compilation and compatibility with the project dependencies, particularly for Cloudflare Workers types and module resolution.

Edit the content of the `tsconfig.json` file:

```json
{
    "compilerOptions": {
        "target": "ES2022",
        "lib": ["ES2022"],
        "jsx": "react-jsx",
        "module": "ES2022",
        "moduleResolution": "node",
        "types": ["@cloudflare/workers-types"],
        "baseUrl": ".",
        "paths": {
            "@/*": ["./src/*"]
        },
        "resolveJsonModule": true,
        "allowJs": true,
        "checkJs": false,
        "noEmit": true,
        "isolatedModules": true,
        "allowSyntheticDefaultImports": true,
        "forceConsistentCasingInFileNames": true,
        "strict": true,
        "skipLibCheck": true
    },
    "include": ["src/**/*", "worker-configuration.d.ts"]
}
```

You can find source code for this project on: [GitHub](https://github.com/shinchan79/content-version-system.git). Next parts will explain the main components of this project.


## 2. Define the data structures for a version control system

Now, we will create code files inside the 'src' directory to implement out functions. File structute will be as follows:

```sh
.src
		‚îî‚îÄ‚îÄ‚îÄtypes.ts     <--- Interface definitions for data structures
		‚îî‚îÄ‚îÄ‚îÄindex.ts     <--- Entry point for request routing and presentation
		‚îî‚îÄ‚îÄ‚îÄcontentDO.ts <--- Core business logic
```

The data structures that will be used by the Durable Object and the Worker to handle state management must first be defined. In this step the following data will be defined:

- The different states a content version can have (`draft`, `published` and `archived`).
- The core data structure for version management, such as a version id number, the contained content and the attached version message.
- The data structure to track version events and history.
- The API response structure.

Add the following code to the `src/types.ts` file:

```
// Core version statuses - Define possible states of a content version
export enum VersionStatus {
  DRAFT = 'draft',
  PUBLISHED = 'published',
  ARCHIVED = 'archived'
}

// Version & tag structures - Define core data structures for version management
export interface Version {
  id: number;
  content: string;
  timestamp: string;
  message: string;
  diff?: ContentDiff;
  status: VersionStatus;
}

export interface Tag {
  name: string;
  versionId: number;
  createdAt: string;
  updatedAt?: string;
}

// State management - Define how content versions and states are tracked
export interface ContentState {
  currentVersion: number;
  versions: Version[];
  tags: { [key: string]: Tag };
  content: string | null;
  publishHistory: PublishRecord[];
}

// Change tracking - tracking differences between versions
export interface ContentDiff {
  from: string;
  to: string;
  changes: {
    additions: number;
    deletions: number;
    totalChanges: number;
    timestamp: string;
  };
  patch: string;
  hunks: Array<{
    oldStart: number;
    oldLines: number;
    newStart: number;
    newLines: number;
    lines: string[];
  }>;
}

// Publishing system - Track publishing events and history
export interface PublishRecord {
  versionId: number;
  publishedAt: string;
  publishedBy: string;
}

// API response types - Standardized response structures for the API
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export interface DeleteVersionResponse {
  success: boolean;
  message: string;
}

export interface TagResponse {
  tagName: string;
  versionId: number;
}

export interface CurrentVersionResponse {
  version: number;
  content: string | null;
}

export type VersionListItem = Omit<Version, 'content' | 'diff'>;
```

## 3. Handle requests sent to the Durable Object

Cloudflare Workers will route incoming requests to the Durable Objects instance. The Durable Objects instance then processes the request, and provides the appropriate response to the Worker.

To handle incoming requests, add the following code to `src/index.ts`:

### Initial setup and HTML template
```
import { ContentDO } from './contentDO';

interface Env {
  CONTENT: DurableObjectNamespace;
}

// HTML Template & Styling. This is used to display the published content when the user navigates to the root URL.
// For full HTML template and styling details, see the GitHub repository.
const getHtmlTemplate = (content: string, message: string = '', timestamp: string = '') => `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Content Version System</title>
    <style>
        body { font-family: system-ui, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .content { background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .button { background: #0070f3; color: white; padding: 12px 24px; border-radius: 5px; }
    </style>
</head>
<body>
    <h1>Content Version System</h1>
    <div class="content">
        <div class="meta">
            <strong>Message:</strong> ${message}<br>
            <strong>Last Updated:</strong> ${new Date(timestamp).toLocaleString()}
        </div>
        <pre>${content}</pre>
    </div>
    <a href="http://localhost:3000" class="button">Content Version Management</a>
</body>
</html>
`;
```
### CORS and helper functions

You need to set up CORS headers to allow cross-origin requests. Add CORS headers and version management helper as below:

```
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, HEAD, POST, PUT, OPTIONS, DELETE',
  'Access-Control-Allow-Headers': 'Content-Type',
};

// Helper function to get latest published version from Durable Objects
async function getLatestPublishedVersion(contentDO: DurableObjectInstance, origin: string) {
  const versionsResponse = await contentDO.fetch(new Request(origin + '/content/default/versions'));
  const versions = await versionsResponse.json();
  const publishedVersions = versions.filter((v: any) => v.status === 'published');
  return publishedVersions.length ? 
    publishedVersions.reduce((latest: any, current: any) => latest.id > current.id ? latest : current) : 
    null;
}
```
### Request handler

The following code will handle the main requests.

```
export { ContentDO };

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    try {
      const url = new URL(request.url);
      // Handle CORS preflight
      if (request.method === 'OPTIONS') {
        return new Response(null, { headers: corsHeaders });
      }
      // Get Durable Objects instance
      const doId = env.CONTENT.idFromName('default');
      const contentDO = env.CONTENT.get(doId);
      // Handle root path - show HTML view
      if (url.pathname === '/') {
        const latestPublished = await getLatestPublishedVersion(contentDO, url.origin);
        if (!latestPublished) {
          return new Response(getHtmlTemplate('No published content', 'No versions', ''), {
            headers: { 'Content-Type': 'text/html' }
          });
        }
        const contentResponse = await contentDO.fetch(
          new Request(`${url.origin}/content/default/versions/${latestPublished.id}`)
        );
        const contentData = await contentResponse.json();

        return new Response(
          getHtmlTemplate(
            contentData.content || 'No content available',
            contentData.message,
            contentData.timestamp
          ), {
            headers: { 'Content-Type': 'text/html' }
          }
        );
      }

      // Special handling for /content/default
      if (url.pathname === '/content/default') {
        const latestPublished = await getLatestPublishedVersion(contentDO, url.origin);
        if (!latestPublished) {
          return new Response(JSON.stringify({ error: 'No published content' }), {
            status: 404,
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
        const contentResponse = await contentDO.fetch(
          new Request(`${url.origin}/content/default/versions/${latestPublished.id}`)
        );
        return new Response(await contentResponse.text(), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }

      // Forward other requests to Durable Objects
      const response = await contentDO.fetch(request);
      const newResponse = new Response(response.body, response);
      Object.entries(corsHeaders).forEach(([key, value]) => {
        newResponse.headers.set(key, value);
      });
      return newResponse;
    } catch (error) {
      console.error('Worker error:', error);
      return new Response(JSON.stringify({
        error: 'Internal Server Error',
        message: error.message
      }), {
        status: 500,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }
  }
};
```

## 4. Build the core version control system logic

To handle version control functions, add the following code to `src/contentDO.ts`:

This file allow you to perform Create - Update - Delete - Read (CRUD) operations on the content versions and the version tags. Additionally, it is possible to either publish or unpublish a version, obtain detailed information on the modification history, compare versions (similar to the git `diff command`), and go back to a particular version.
- All the states are recorded in the Durable Object storage.
- Operations occur in the following order: read the state ‚Üí process changes ‚Üí write the changes.
- All operations are asynchronous because of storage communications
- There are 2 important things you have to pay attention to: First, you need to setup the CORS headers to allow cross-origin requests. Second, the class name of the Durable Object must match the name defined in the wrangler.toml file (Otherwise, error when you run `wrangler deploy` command).

### Initial Setup and Class Definition

```
import { createPatch } from 'diff';
import { ContentDiff, ContentState, Version, PublishRecord, VersionStatus, Tag } from './types';
// You will need to set up CORS headers (cross-origin requests) for your application to work properly with Durable Objects.
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type',
};
// Note that the name of the class have to match the name of the Durable Object defined in the wrangler.toml file.
export class ContentDO {
  private state: DurableObjectState;
  private env: any;

  constructor(state: DurableObjectState, env: any) {
    this.state = state;
    this.env = env;
  }
}
```

### Request handling and routing

Add request handling methods:

```
// Entry point for requests to the Durable Object
async fetch(request: Request): Promise<Response> {
  if (request.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const url = new URL(request.url);
    const parts = url.pathname.split('/').filter(Boolean);
    const response = await this.handleRequest(request, parts);
    
    Object.entries(corsHeaders).forEach(([key, value]) => {
      response.headers.set(key, value);
    });

    return response;
  } catch (err) {
    const error = err as Error;
    return new Response(error.message, { status: 500, headers: corsHeaders });
  }
}

private async handleRequest(request: Request, parts: string[]): Promise<Response> {
  const path = parts.join('/');
  
  switch (`${request.method} ${path}`) {
    case 'POST content': {
      const { content, message } = await request.json();
      return Response.json(await this.createVersion(content, message));
    }
    // Add other route handlers here (You can see the full code on GitHub repository)
    default:
      return new Response('No route matched', { status: 404 });
  }
}
```
### Core Version Control Functions

Following are the basic version control operations. For complete implementation details, see GitHub repository:

```
// Initialize or get existing state from Durable Objects storage
private async initialize(): Promise<ContentState> {
  // Get existing state from Durable Objects storage
  const stored = await this.state.storage.get<ContentState>("content");
  if (!stored) {
    // Initialize the state if not existed
    const initialData: ContentState = {
      currentVersion: 0,
      versions: [],
      tags: {},
      content: null,
      publishHistory: []
    };
    // Store state to Durabe Objects storag
    await this.state.storage.put("content", initialData);
    return initialData;
  }
  return stored;
}
// Get current state from Durable Object storage & Update the state with new version
async createVersion(content: string, message: string = ""): Promise<Version> {
  const data = await this.initialize();
  const newVersion: Version = {
    id: data.versions.length + 1,
    content,
    timestamp: new Date().toISOString(),
    message,
    status: VersionStatus.DRAFT,
    diff: data.content ? this.calculateDetailedDiff(data.content, content) : null
  };
  
  data.versions.push(newVersion);
  data.currentVersion = newVersion.id;
  data.content = content;

  await this.state.storage.put("content", data);
  return newVersion;
}
async getVersion(id: number): Promise<Version | null> {
  const data = await this.initialize();
  return data.versions.find(v => v.id === id) || null;
}

async getVersions(): Promise<Version[]> {
  const data = await this.initialize();
  return data.versions;
}
```

### Tag Management functions

```
async createTag(versionId: number, name: string): Promise<Tag> {
  const data = await this.initialize();
  const version = data.versions.find(v => v.id === versionId);
  if (!version) throw new Error("Version not found");
  if (data.tags[name]) throw new Error("Tag exists");

  const newTag: Tag = {
    name,
    versionId,
    createdAt: new Date().toISOString()
  };
  data.tags[name] = newTag;
  await this.state.storage.put("content", data);
  return newTag;
}

async getTags(): Promise<Tag[]> {
  const data = await this.initialize();
  return Object.values(data.tags);
}
async getVersionTags(versionId: number): Promise<Tag[]> {
  const data = await this.initialize();
return Object.values(data.tags).filter(tag => tag.versionId === versionId);
}
```

### Publishing and Unpublishing functions

```
async publishVersion(versionId: number, publishedBy: string): Promise<PublishRecord> {
  const data = await this.initialize();
  const version = data.versions.find(v => v.id === versionId);
  if (!version) throw new Error("Version not found");

  const publishRecord: PublishRecord = {
    versionId,
    publishedAt: new Date().toISOString(),
    publishedBy
  };
  data.publishHistory = [...(data.publishHistory || []), publishRecord];
  await this.state.storage.put("content", data);
  return publishRecord;
}

// Unpublish a version
async unpublishVersion(versionId: number): Promise<Version> {
  const data = await this.initialize();
  const version = data.versions.find(v => v.id === versionId);
  if (!version) {
    throw new Error("Version not found");
  }
  data.versions = data.versions.map(v => ({
    ...v,
    status: v.id === versionId ? VersionStatus.DRAFT : v.status
  }));
  if (data.publishHistory) {
    data.publishHistory = data.publishHistory.filter(
    record => record.versionId !== versionId
    );
  }
  if (data.currentVersion === versionId) {
    data.currentVersion = 0;
    data.content = null;
  }
  await this.state.storage.put("content", data);
  const updatedVersion = data.versions.find(v => v.id === versionId);
  if (!updatedVersion) {
    throw new Error("Failed to get updated version");
  }
  return updatedVersion;
}

async getPublishHistory(): Promise<PublishRecord[]> {
  const data = await this.initialize();
  return data.publishHistory || [];
}
```

### Diff and Version Control Operations

```
async compareVersions(fromId: number, toId: number):     Promise<ContentDiff> {
  const data = await this.initialize();
  const fromVersion = data.versions.find(v => v.id === fromId);
  const toVersion = data.versions.find(v => v.id === toId);
  if (!fromVersion || !toVersion) {
    throw new Error("Version not found");
  }
  return this.calculateDetailedDiff(fromVersion.content, toVersion.content);
}

private calculateDetailedDiff(oldContent: string, newContent: string): ContentDiff {
  const patch = createPatch('content', oldContent, newContent, 'old', 'new');
  return {
    from: oldContent,
    to: newContent,
    changes: {
      additions: newContent.split('\n').length - oldContent.split('\n').length,
      deletions: Math.max(0, oldContent.split('\n').length - newContent.split('\n').length),
      totalChanges: Math.abs(newContent.split('\n').length - oldContent.split('\n').length),
      timestamp: new Date().toISOString()
    },
    patch,
    hunks: []
  };
}

async getDiff(fromId: number, toId: number): Promise<Response> {
  const data = await this.initialize();
  const fromVersion = data.versions.find(v => v.id === fromId);
  const toVersion = data.versions.find(v => v.id === toId);
  if (!fromVersion || !toVersion) throw new Error("Version not found");

  return new Response(createPatch('content.txt',
    fromVersion.content || '',
    toVersion.content || '',
    `Version ${fromVersion.id}`,
    `Version ${toVersion.id}`
  ), {
    headers: {
      'Content-Type': 'text/plain',
      'Access-Control-Allow-Origin': '*',
    }
  });
}

async revertTo(versionId: number): Promise<Version> {
  const data = await this.initialize();
  const targetVersion = data.versions.find(v => v.id === versionId);
  if (!targetVersion) throw new Error("Version not found");
  return this.createVersion(targetVersion.content, `Reverted to version ${versionId}`);
}
```
## 5. Testing and Deployment

You can test your project locally using Wrangler:

```sh
npx wrangler dev
```

In your browser, navigate to `http://localhost:8787` to preview your project.

When you are happy with the result, deploy your project:

```sh
wrangler deploy
```

Here are some commands that you can use to test your project after deployment:

### Version Management Operations

```
# Create a new version
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"content": "Version 1 content", "message": "First version"}' \
  https://<your-worker-url>/content

# Get current version
curl -X GET \
  https://<your-worker-url>/content/default

# List all versions
curl -X GET \
  https://<your-worker-url>/content/default/versions

# Get specific version
curl -X GET \
  https://<your-worker-url>/content/default/versions/{id}

# Compare versions
curl -X GET \
  https://<your-worker-url>/content/default/versions/8/diff?compare=13
```

### Tag operations

```
# Create a new tag
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"versionId": 1, "name": "v1.0"}' \
  https://<your-worker-url>/content/versions/tags

# List all tags
curl -X GET \
  https://<your-worker-url>/content/versions/tags

# Update tag name
curl -X PUT \
  -H "Content-Type: application/json" \
  -d '{"newName": "stable"}' \
  https://<your-worker-url>/content/versions/tags/v1.0
```

### Publish and unpublish operations

```
# Publish a version
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"publishedBy": "test-user"}' \
  https://<your-worker-url>/content/default/versions/{id}/publish

# View publication history
curl -X GET \
  https://<your-worker-url>/content/default/publish-history
```

## 6. Additional resources
If you want to implement CI/CD for Worker platform, you can navigate to this blog: [Continuous Deployment for Cloudflare Workers with GitHub Actions](https://blog.cloudflare.com/workers-builds-integrated-ci-cd-built-on-the-workers-platform/)

You can find source code for this project on: [GitHub](https://github.com/shinchan79/content-version-system.git)
